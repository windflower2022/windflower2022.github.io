<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>5特效丝滑幻灯片（淡进淡出+溶解+像素化+马赛克+碎片飞散）</title>
<style>
/* 容器基础样式 - 保证6张图展示空间 */
#mydiv { 
    margin: 150px 0 30px;
	display: grid;
	place-items: center;
	width: 1600px;
	height: 900px;
	background-color: #000205;
	user-select: none;
	overflow: hidden;
	position: relative;
	z-index: 1;  
}

/* 核心：幻灯片基础样式（重点优化淡进淡出过渡） */
.slide {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0;
  /* 淡进淡出过渡时间1.5s，ease缓动更自然，与其他效果衔接无断层 */
  transition: opacity 1.5s ease; 
}

.slide img {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

/* 覆盖视频 - 仅作氛围，不干扰效果过渡 */
#overlay {
  position: absolute;
  top: -60px;
  left: 0;
  width: 100%;
  height: calc(100% + 80px);
  object-fit: cover;
  mix-blend-mode: overlay;
  opacity: 0.0;
  z-index: 50;
  pointer-events: none;
}

/* 1. 统一块级效果容器（溶解/像素化/马赛克共用，保证样式一致性） */
.block-effect-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 10;
  display: grid;
  transition: opacity 0.3s linear;
}

/* 1.1 溶解效果 - 细腻块级（30列×20行，过渡更丝滑） */
.dissolve-wrapper {
  grid-template-columns: repeat(30, 1fr);
  grid-template-rows: repeat(20, 1fr);
}

/* 1.2 像素化效果 - 清晰像素感（40列×30行，过渡无卡顿） */
.pixelate-wrapper {
  grid-template-columns: repeat(40, 1fr);
  grid-template-rows: repeat(30, 1fr);
}

/* 1.3 马赛克效果 - 粗犷但流畅（15列×10行，大色块过渡不突兀） */
.mosaic-wrapper {
  grid-template-columns: repeat(15, 1fr);
  grid-template-rows: repeat(10, 1fr);
}

/* 统一块级元素样式 - 所有块级效果过渡参数统一，避免断层 */
.block-piece {
  background-color: #000205;
  transition: all 1.2s cubic-bezier(0.2, 0.8, 0.2, 1); /* 缓动曲线优化，过渡更自然 */
  opacity: 1;
  transform: scale(1);
}

/* 2. 碎片飞散效果 - 3D过渡增强流畅感 */
.shatter-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 10;
  perspective: 1500px; /* 3D空间感，碎片飞散不杂乱 */
}

.shatter-piece {
  position: absolute;
  background-color: #000205;
  /* 飞散过渡1.8s，缓动更柔和，避免生硬 */
  transition: transform 1.8s cubic-bezier(0.1, 0.9, 0.3, 1.2), opacity 1.5s ease;
  opacity: 1;
  transform-origin: center center;
  border-radius: 2px; /* 轻微圆角，过渡更柔和 */
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* 底层视频 - 不干扰图片过渡，仅作氛围补充 */
#vid1 {
  position: absolute;
  width: 100%;
  height: 110%;
  top:-80px;
  object-fit: cover;
  pointer-events: none;
  mix-blend-mode: screen;
  z-index: 2;
  opacity: 0.0;
}
#vid2 {
  position: absolute;
  width: 100%;
  height: 110%;
  top:-80px;
  object-fit: cover;
  pointer-events: none;
  mix-blend-mode: screen;
  -webkit-mask: linear-gradient(to bottom, red 50%, transparent 55%, transparent);
  z-index: 3;
  opacity: 0.0;
}
</style> 
<body>
<div id="mydiv">
  <!-- 6张图片完整保留，确保循环切换 -->
  <div class="slide" style="opacity: 1;">
    <img src="https://i.ibb.co/sdPBn9WS/wsrjcck1.jpg" alt="图片1">
  </div>
  <div class="slide">
    <img src="https://i.ibb.co/WNDynD3X/wsrjcck3.jpg" alt="图片2">
  </div>
  <div class="slide">
    <img src="https://i.ibb.co/cSkScBb0/wsrjcck2.jpg" alt="图片3">
  </div>
  <div class="slide">
    <img src="https://i.ibb.co/v413rpmn/wsrjcck4.jpg" alt="图片4">
  </div>
  <div class="slide">
    <img src="https://i.ibb.co/mF1hP4qM/wsrjcck5.jpg" alt="图片5">
  </div>
  <div class="slide">
    <img src="https://i.ibb.co/0VXmrndC/wsrjcck6.jpg" alt="图片6">
  </div>
  
  <!-- 视频覆盖层（保留，不影响效果过渡） -->
  <video id="overlay" autoplay loop muted playsinline>
    <source src="https://img.tukuppt.com/video_show/2422006/00/01/70/5b4b1e2590ccc.mp4" type="video/mp4">
  </video>
  
  <video id="vid1" src="https://img.tukuppt.com/video_show/2629112/00/02/23/5b5885f450f50.mp4" autoplay loop muted></video>
  <video id="vid2" src="https://img.tukuppt.com/video_show/15653652/00/80/83/60d04564c32f7.mp4" autoplay loop muted></video>
</div>  

<!-- JS 逻辑部分见第二部分 -->
<script>
    // 基础变量 - 适配6张图+5种效果循环
    let currentIndex = 0;
    const slides = document.querySelectorAll('.slide');
    const totalSlides = slides.length; // 自动识别6张图
    let timer;
    let effectIndex = 0;
    
    // 核心：5种效果列表（仅保留用户指定效果，顺序可调整）
    const effects = [
      {func: applyFadeEffect},    // 1. 淡进淡出
      {func: applyDissolveEffect}, // 2. 溶解
      {func: applyPixelateEffect}, // 3. 像素化
      {func: applyMosaicEffect},   // 4. 马赛克
      {func: applyShatterEffect}   // 5. 碎片飞散
    ];
    
    // 工具函数：创建统一容器（溶解/像素化/马赛克共用，减少冗余）
    function createWrapper(className) {
      const wrapper = document.createElement('div');
      wrapper.className = className;
      return wrapper;
    }
    
    // 工具函数：创建统一块级元素（保证块级效果样式一致性）
    function createBlockPiece() {
      const piece = document.createElement('div');
      piece.className = 'block-piece';
      return piece;
    }
    
    // 初始化：页面加载后启动幻灯片
    function init() {
      startTimer();
    }
    
    // 关键：清除所有特效残留（避免前效果干扰下一张图，过渡核心保障）
    function clearEffects() {
      const containers = document.querySelectorAll(
        '.block-effect-wrapper, .shatter-wrapper' // 仅清除当前5种效果的容器
      );
      containers.forEach(container => container.remove());
      
      // 重置所有幻灯片样式，防止透明度叠加导致过渡突兀
      slides.forEach(slide => {
        slide.style.opacity = '0';
        slide.style.transition = 'opacity 1.5s ease'; // 恢复淡进淡出基础过渡
      });
    }
    
    // 核心切换逻辑：5种效果循环应用到6张图
    function showNext() {
      clearEffects(); // 先清残留，再切图（关键：避免过渡断层）
      
      // 6张图循环（取余自动适配）
      currentIndex = (currentIndex + 1) % totalSlides;
      // 5种效果循环（取余自动适配）
      const effect = effects[effectIndex];
      effectIndex = (effectIndex + 1) % effects.length;
      
      const targetSlide = slides[currentIndex];
      effect.func(targetSlide); // 执行当前效果
      
      resetTimer(); // 重置定时器，保证每张图展示7秒
    }
    
    // 1. 淡进淡出效果（极简逻辑，过渡最自然）
    function applyFadeEffect(slide) {
      // 直接利用slide的opacity过渡，无需额外容器
      slide.style.opacity = '1'; 
      // 若需增强：可添加轻微缩放（可选）
      // slide.style.transform = 'scale(1.02)';
      // slide.style.transition = 'opacity 1.5s ease, transform 1.5s ease';
    }
    
    // 2. 溶解效果（细腻过渡，无突兀感）
    function applyDissolveEffect(slide) {
      slide.style.opacity = '1'; // 先显示图片，再用黑色块"溶解"
      const wrapper = createWrapper('block-effect-wrapper dissolve-wrapper');
      slide.appendChild(wrapper);
      
      const totalPieces = 30 * 20; // 600个小块，溶解更细腻
      for(let i = 0; i < totalPieces; i++) {
        const piece = createBlockPiece();
        // 0.1-1s随机延迟，模拟自然溶解（避免机械同步）
        piece.style.transitionDelay = `${0.1 + Math.random() * 0.9}s`;
        wrapper.appendChild(piece);
      }
      
      // 延迟触发溶解（让图片先显示，再开始"消失"黑色块）
      setTimeout(() => {
        wrapper.querySelectorAll('.block-piece').forEach(piece => {
          piece.style.opacity = '0';
          piece.style.transform = 'scale(0.8)'; // 轻微缩放，增强溶解层次感
        });
      }, 100);
    }
    
    // 3. 像素化效果（扫描式过渡，流畅无卡顿）
    function applyPixelateEffect(slide) {
      slide.style.opacity = '1';
      const wrapper = createWrapper('block-effect-wrapper pixelate-wrapper');
      slide.appendChild(wrapper);
      
      const totalPieces = 40 * 30; // 1200个像素块，过渡更连贯
      for(let i = 0; i < totalPieces; i++) {
        const piece = createBlockPiece();
        // 按"行+列"延迟（行0.02s+列0.01s），模拟横向扫描效果
        const row = Math.floor(i / 40);
        const col = i % 40;
        piece.style.transitionDelay = `${(row * 0.02) + (col * 0.01)}s`;
        wrapper.appendChild(piece);
      }
      
      setTimeout(() => {
        wrapper.querySelectorAll('.block-piece').forEach(piece => {
          // 随机上下左右位移，增强像素"散开"感
          const dirs = ['translateX(-50%)', 'translateX(50%)', 'translateY(-50%)', 'translateY(50%)'];
          piece.style.transform = dirs[Math.floor(Math.random() * dirs.length)];
          piece.style.opacity = '0';
        });
      }, 100);
    }
    
    // 4. 马赛克效果（粗犷但流畅，过渡有节奏）
    function applyMosaicEffect(slide) {
      slide.style.opacity = '1';
      const wrapper = createWrapper('block-effect-wrapper mosaic-wrapper');
      slide.appendChild(wrapper);
      
      const totalPieces = 15 * 10; // 150个大色块，过渡不拖沓
      for(let i = 0; i < totalPieces; i++) {
        const piece = createBlockPiece();
        // 按"对角线"延迟（行+列）×0.05s，过渡有规律不杂乱
        const row = Math.floor(i / 15);
        const col = i % 15;
        piece.style.transitionDelay = `${(row + col) * 0.05}s`;
        wrapper.appendChild(piece);
      }
      
      setTimeout(() => {
        wrapper.querySelectorAll('.block-piece').forEach(piece => {
          piece.style.transform = 'scale(0)'; // 缩放至消失，过渡自然
          piece.style.opacity = '0';
        });
      }, 100);
    }
    
    // 5. 碎片飞散效果（3D过渡，丝滑无生硬感）
    function applyShatterEffect(slide) {
      slide.style.opacity = '1';
      const wrapper = createWrapper('shatter-wrapper');
      slide.appendChild(wrapper);
      
      const pieceCount = 80; // 80个碎片，飞散不杂乱
      const containerWidth = 1600;
      const containerHeight = 900;
      
      for(let i = 0; i < pieceCount; i++) {
        const piece = document.createElement('div');
        piece.className = 'shatter-piece';
        
        // 随机碎片尺寸（50-180px），避免统一感
        const pieceWidth = 50 + Math.random() * 130;
        const pieceHeight = 50 + Math.random() * 130;
        // 随机位置，确保覆盖全屏
        const x = Math.min(Math.random() * containerWidth, containerWidth - pieceWidth);
        const y = Math.min(Math.random() * containerHeight, containerHeight - pieceHeight);
        
        piece.style.width = `${pieceWidth}px`;
        piece.style.height = `${pieceHeight}px`;
        piece.style.left = `${x}px`;
        piece.style.top = `${y}px`;
        // 0-0.8s随机延迟，飞散更自然
        piece.style.transitionDelay = `${Math.random() * 0.8}s`;
        wrapper.appendChild(piece);
      }
      
      setTimeout(() => {
        wrapper.querySelectorAll('.shatter-piece').forEach(piece => {
          // 随机飞散方向（0-360度）
          const angle = Math.random() * Math.PI * 2;
          // 随机飞散距离（500-1000px），增强层次感
          const distance = 500 + Math.random() * 500;
          const x = Math.cos(angle) * distance;
          const y = Math.sin(angle) * distance;
          // 随机Z轴旋转（-360~360度），3D感更强
          const rotateZ = Math.random() * 720 - 360;
          
          piece.style.transform = `translate3d(${x}px, ${y}px, 300px) rotateZ(${rotateZ}deg)`;
          piece.style.opacity = '0';
        });
      }, 100);
    }
    
    // 定时器控制：7秒切换一次（给足效果展示时间，过渡不仓促）
    function startTimer() {
      timer = setInterval(showNext, 7000);
    }
    
    // 重置定时器：确保每张图展示时间一致
    function resetTimer() {
      clearInterval(timer);
      startTimer();
    }
    
    // 页面加载完成后启动
    window.onload = init;
    </script>
    </body>
    </html>