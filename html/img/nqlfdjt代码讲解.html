<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title></title>
<style>
#mydiv { 
    margin: 0px 0 30px;
	display: grid;
	place-items: center;
	width: 1600px;
	height: 900px;
	background-color: #000205;
	user-select: none;
	overflow: hidden;
	position: relative;
	z-index: 1;  
}

/* 幻灯片基础样式 - 无淡入淡出，由特效控制显示 */
.slide {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0; /* 初始全透明，依赖特效触发显示 */
}

.slide img {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

/* 覆盖视频 - 仅作氛围，不干扰特效 */
#overlay {
  position: absolute;
  top: -60px;
  left: 0;
  width: 100%;
  height: calc(100% + 80px);
  object-fit: cover;
  mix-blend-mode: overlay;
  opacity: 0.0;
  z-index: 50;
  pointer-events: none;
}

/* 1. 块级效果容器（溶解/像素化/马赛克共用） */
.block-effect-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 10;
  display: grid;
  transition: opacity 0.3s linear;
}

/* 1.1 溶解效果 - 细腻块级 */
.dissolve-wrapper {
  grid-template-columns: repeat(30, 1fr);
  grid-template-rows: repeat(20, 1fr);
}

/* 1.2 像素化效果 - 清晰像素感 */
.pixelate-wrapper {
  grid-template-columns: repeat(40, 1fr);
  grid-template-rows: repeat(30, 1fr);
}

/* 1.3 马赛克效果 - 粗犷块级 */
.mosaic-wrapper {
  grid-template-columns: repeat(15, 1fr);
  grid-template-rows: repeat(10, 1fr);
}

/* 统一块级元素样式 - 过渡参数保持一致，确保流畅性 */
.block-piece {
  background-color: #000205;
  transition: all 1.2s cubic-bezier(0.2, 0.8, 0.2, 1);
  opacity: 1;
  transform: scale(1);
}

/* 2. 碎片飞散效果 - 3D过渡风格不变 */
.shatter-wrapper {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 10;
  perspective: 1500px; /* 增强3D空间感，飞散更自然 */
}

.shatter-piece {
  position: absolute;
  background-color: #000205;
  transition: transform 1.8s cubic-bezier(0.1, 0.9, 0.3, 1.2), opacity 1.5s ease;
  opacity: 1;
  transform-origin: center center;
  border-radius: 2px; /* 轻微圆角，避免尖锐感 */
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* 底层视频 - 保持氛围不干扰 */
#vid1, #vid2 {
  position: absolute;
  width: 100%;
  height: 110%;
  top: -80px;
  object-fit: cover;
  pointer-events: none;
  mix-blend-mode: screen;
  opacity: 0.0;
}
#vid1 { z-index: 2; }
#vid2 { 
  z-index: 3;
  -webkit-mask: linear-gradient(to bottom, red 50%, transparent 55%, transparent);
}
</style> 
<body>
<div id="mydiv">
  <!-- 6张图片结构不变，初始全透明由特效控制显示 -->
  <div class="slide">
    <img src="https://i.postimg.cc/X43kRr3N/nqlfdjt1.png" alt="图片1">
  </div>
  <div class="slide">
    <img src="https://i.postimg.cc/Lm8BsGnk/nqlfdjt2.png" alt="图片2">
  </div>
  <div class="slide">
    <img src="https://i.postimg.cc/5f2qtD67/nqlfdjt3.png" alt="图片3">
  </div>
  <div class="slide">
    <img src="https://i.postimg.cc/6BpLQFyh/nqlfdjt4.png" alt="图片4">
  </div>
  <div class="slide">
    <img src="https://i.postimg.cc/6BpLQFyY/nqlfdjt5.png" alt="图片5">
  </div>
  <div class="slide">
    <img src="https://i.postimg.cc/7qt1JX2R/nqlfdjt6.png" alt="图片6">
  </div>
  
  <!-- 视频覆盖层 -->
  <video id="overlay" autoplay loop muted playsinline>
    <source src="https://img.tukuppt.com/video_show/2422006/00/01/70/5b4b1e2590ccc.mp4" type="video/mp4">
  </video>
  
  <video id="vid1" src="https://img.tukuppt.com/video_show/2629112/00/02/23/5b5885f450f50.mp4" autoplay loop muted></video>
  <video id="vid2" src="https://img.tukuppt.com/video_show/15653652/00/80/83/60d04564c32f7.mp4" autoplay loop muted></video>
</div>  

<!-- JS 逻辑见第二部分 --><script>
// 基础变量 - 6张图循环，4种特效轮换
let currentIndex = 0;
const slides = document.querySelectorAll('.slide');
const totalSlides = slides.length; // 自动识别6张图
let timer;
let effectIndex = 0;

// 核心效果列表 - 仅保留4种目标特效（移除百叶窗）
const effects = [
  {func: applyDissolveEffect},    // 1. 溶解
  {func: applyMosaicEffect},      // 2. 马赛克
  {func: applyShatterEffect},     // 3. 碎片飞散
  {func: applyPixelateEffect}     // 4. 像素化
];

// 工具函数：创建统一容器（溶解/像素化/马赛克共用）
function createWrapper(className) {
  const wrapper = document.createElement('div');
  wrapper.className = className;
  return wrapper;
}

// 工具函数：创建统一块级元素（保证块级效果样式一致性）
function createBlockPiece() {
  const piece = document.createElement('div');
  piece.className = 'block-piece';
  return piece;
}

// 初始化：页面加载后立即用特效显示第一张图（无默认显示，进入即有特效）
function init() {
  const firstSlide = slides[currentIndex];
  effects[effectIndex].func(firstSlide); // 对第一张图应用第一个特效
  effectIndex = (effectIndex + 1) % effects.length; // 切换下一个特效，准备下次使用
  startTimer(); // 启动自动切换定时器
}

// 清除所有特效残留（仅针对4种核心特效容器，避免冗余清理）
function clearEffects() {
  const containers = document.querySelectorAll(
    '.block-effect-wrapper, .shatter-wrapper' // 移除百叶窗容器类名
  );
  containers.forEach(container => container.remove());
  
  // 重置所有幻灯片为透明，防止叠加干扰
  slides.forEach(slide => {
    slide.style.opacity = '0';
  });
}

// 切换逻辑：4种特效循环应用到6张图，过渡连贯
function showNext() {
  clearEffects(); // 先清除上一个特效残留，再切换图片
  currentIndex = (currentIndex + 1) % totalSlides; // 6张图循环
  const currentEffect = effects[effectIndex];
  effectIndex = (effectIndex + 1) % effects.length; // 4种特效循环
  
  const targetSlide = slides[currentIndex];
  currentEffect.func(targetSlide); // 对当前图片应用当前特效
  resetTimer(); // 重置定时器，确保每张图展示7秒
}

// 1. 溶解效果 - 细腻过渡，保持原有逻辑
function applyDissolveEffect(slide) {
  slide.style.opacity = '1'; // 先显示图片
  const wrapper = createWrapper('block-effect-wrapper dissolve-wrapper');
  slide.appendChild(wrapper);
  
  const totalPieces = 30 * 20; // 600个小块，溶解更细腻
  for(let i = 0; i < totalPieces; i++) {
    const piece = createBlockPiece();
    // 0.1-1s随机延迟，模拟自然溶解（避免机械同步）
    piece.style.transitionDelay = `${0.1 + Math.random() * 0.9}s`;
    wrapper.appendChild(piece);
  }
  
  // 延迟触发溶解（让图片先完整显示，再开始"消失"黑色块）
  setTimeout(() => {
    wrapper.querySelectorAll('.block-piece').forEach(piece => {
      piece.style.opacity = '0';
      piece.style.transform = 'scale(0.8)'; // 轻微缩放，增强层次感
    });
  }, 100);
}

// 2. 马赛克效果 - 粗犷块级过渡，逻辑不变
function applyMosaicEffect(slide) {
  slide.style.opacity = '1';
  const wrapper = createWrapper('block-effect-wrapper mosaic-wrapper');
  slide.appendChild(wrapper);
  
  const totalPieces = 15 * 10; // 150个大色块，过渡不拖沓
  for(let i = 0; i < totalPieces; i++) {
    const piece = createBlockPiece();
    // 按对角线延迟（行+列）×0.05s，过渡有规律不杂乱
    const row = Math.floor(i / 15);
    const col = i % 15;
    piece.style.transitionDelay = `${(row + col) * 0.05}s`;
    wrapper.appendChild(piece);
  }
  
  setTimeout(() => {
    wrapper.querySelectorAll('.block-piece').forEach(piece => {
      piece.style.transform = 'scale(0)'; // 缩放至消失，过渡自然
      piece.style.opacity = '0';
    });
  }, 100);
}

// 3. 碎片飞散效果 - 3D过渡，保持原有动感
function applyShatterEffect(slide) {
  slide.style.opacity = '1';
  const wrapper = createWrapper('shatter-wrapper');
  slide.appendChild(wrapper);
  
  const pieceCount = 80; // 80个碎片，飞散不杂乱
  const containerWidth = 1600;
  const containerHeight = 900;
  
  for(let i = 0; i < pieceCount; i++) {
    const piece = document.createElement('div');
    piece.className = 'shatter-piece';
    
    // 随机碎片尺寸（50-180px），避免统一感
    const pieceWidth = 50 + Math.random() * 130;
    const pieceHeight = 50 + Math.random() * 130;
    // 随机位置，确保覆盖全屏
    const x = Math.min(Math.random() * containerWidth, containerWidth - pieceWidth);
    const y = Math.min(Math.random() * containerHeight, containerHeight - pieceHeight);
    
    piece.style.width = `${pieceWidth}px`;
    piece.style.height = `${pieceHeight}px`;
    piece.style.left = `${x}px`;
    piece.style.top = `${y}px`;
    // 0-0.8s随机延迟，飞散更自然
    piece.style.transitionDelay = `${Math.random() * 0.8}s`;
    wrapper.appendChild(piece);
  }
  
  setTimeout(() => {
    wrapper.querySelectorAll('.shatter-piece').forEach(piece => {
      // 随机飞散方向（0-360度）
      const angle = Math.random() * Math.PI * 2;
      // 随机飞散距离（500-1000px），增强层次感
      const distance = 500 + Math.random() * 500;
      const x = Math.cos(angle) * distance;
      const y = Math.sin(angle) * distance;
      // 随机Z轴旋转（-360~360度），3D感更强
      const rotateZ = Math.random() * 720 - 360;
      
      piece.style.transform = `translate3d(${x}px, ${y}px, 300px) rotateZ(${rotateZ}deg)`;
      piece.style.opacity = '0';
    });
  }, 100);
}

// 4. 像素化效果 - 扫描式过渡，逻辑不变
function applyPixelateEffect(slide) {
  slide.style.opacity = '1';
  const wrapper = createWrapper('block-effect-wrapper pixelate-wrapper');
  slide.appendChild(wrapper);
  
  const totalPieces = 40 * 30; // 1200个像素块，过渡更连贯
  for(let i = 0; i < totalPieces; i++) {
    const piece = createBlockPiece();
    // 按"行+列"延迟（行0.02s+列0.01s），模拟横向扫描效果
    const row = Math.floor(i / 40);
    const col = i % 40;
    piece.style.transitionDelay = `${(row * 0.02) + (col * 0.01)}s`;
    wrapper.appendChild(piece);
  }
  
  setTimeout(() => {
    wrapper.querySelectorAll('.block-piece').forEach(piece => {
      // 随机上下左右位移，增强像素"散开"感
      const dirs = ['translateX(-50%)', 'translateX(50%)', 'translateY(-50%)', 'translateY(50%)'];
      piece.style.transform = dirs[Math.floor(Math.random() * dirs.length)];
      piece.style.opacity = '0';
    });
  }, 100);
}

// 定时器控制：7秒切换一次（给足特效展示时间，避免过渡仓促）
function startTimer() {
  timer = setInterval(showNext, 7000);
}

// 重置定时器：确保每张图展示时间一致
function resetTimer() {
  clearInterval(timer);
  startTimer();
}

// 页面加载完成后启动（进入即有特效）
window.onload = init;
</script>
</body>
</html>